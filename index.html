<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>I Love The Zou</title>

<!-- Favicon: heart SVG -->
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='80' font-size='80'>‚ù§Ô∏è</text></svg>">
<link rel="apple-touch-icon" href="og-image.png">

<!-- Social / Open Graph -->
<meta property="og:title" content="I Love The Zou">
<meta property="og:description" content="A Valentine's Day Game ‚Äî Catch Zouzou! üíï">
<meta property="og:image" content="https://ilovethezou.com/og-image.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta property="og:url" content="https://ilovethezou.com">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="I Love The Zou">
<meta name="twitter:description" content="A Valentine's Day Game ‚Äî Catch Zouzou! üíï">
<meta name="twitter:image" content="https://ilovethezou.com/og-image.png">
<meta name="description" content="A Valentine's Day Game ‚Äî Catch Zouzou! üíï">
<meta name="theme-color" content="#1a0a1e">

<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    overflow: hidden;
    background: #1a0a1e;
    font-family: 'Georgia', serif;
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
  }
  #landing {
    position: fixed; inset: 0;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    background: linear-gradient(135deg, #1a0a1e 0%, #2d1b35 50%, #1a0a1e 100%);
    z-index: 10;
    transition: opacity 0.6s ease;
  }
  #landing.hidden { opacity: 0; pointer-events: none; }
  #landing h1 {
    font-size: clamp(2rem, 8vw, 4rem);
    color: #ff6b8a;
    text-shadow: 0 0 30px rgba(255,107,138,0.5), 0 0 60px rgba(255,107,138,0.2);
    margin-bottom: 0.3rem;
    letter-spacing: 2px;
  }
  #landing .subtitle {
    color: #ffb3c6;
    font-size: clamp(0.9rem, 3vw, 1.3rem);
    margin-bottom: 2.5rem;
    font-style: italic; opacity: 0.8;
  }
  #landing .heart-icon {
    font-size: clamp(2rem, 6vw, 3.5rem);
    margin-bottom: 1rem;
    color: #ff4d6d;
    text-shadow: 0 0 20px rgba(255,77,109,0.6);
    animation: pulse 1.5s ease-in-out infinite;
  }
  .btn {
    padding: 15px 50px;
    font-size: clamp(1rem, 3vw, 1.3rem);
    background: linear-gradient(135deg, #ff6b8a, #ff4d6d);
    color: white; border: none; border-radius: 50px;
    cursor: pointer; font-family: inherit;
    box-shadow: 0 4px 20px rgba(255,77,109,0.4);
    transition: transform 0.2s, box-shadow 0.2s;
    letter-spacing: 1px;
  }
  .btn:hover { transform: scale(1.05); box-shadow: 0 6px 25px rgba(255,77,109,0.6); }
  .btn:active { transform: scale(0.98); }
  #gameCanvas { display: none; position: fixed; inset: 0; }
  #instructions {
    display: none; position: fixed; bottom: 15px;
    left: 50%; transform: translateX(-50%);
    color: rgba(255,179,198,0.5); font-size: 0.8rem;
    z-index: 5; text-align: center; pointer-events: none;
    transition: opacity 2s ease;
  }
  #catchOverlay {
    position: fixed; inset: 0;
    display: none; flex-direction: column;
    align-items: center; justify-content: center;
    background: rgba(26,10,30,0.92);
    z-index: 20; opacity: 0;
    transition: opacity 0.8s ease;
  }
  #catchOverlay.visible { opacity: 1; }
  #catchOverlay h2 {
    font-size: clamp(1.8rem, 7vw, 3rem);
    color: #ff6b8a;
    text-shadow: 0 0 40px rgba(255,107,138,0.8), 0 0 80px rgba(255,107,138,0.3);
    margin-bottom: 0.5rem;
    animation: pulse 1.5s ease-in-out infinite;
  }
  #catchOverlay .timer-text {
    color: #ffb3c6; font-size: 1rem;
    margin-bottom: 1.5rem; opacity: 0.7;
  }
  #catchOverlay canvas { margin-bottom: 1rem; }
  #valentineWrap {
    position: relative;
    margin-bottom: 0.5rem;
  }
  #valentineText {
    font-size: clamp(2.2rem, 9vw, 4.5rem);
    color: #fff;
    text-shadow: 0 0 30px rgba(255,77,109,0.9), 0 0 60px rgba(255,107,138,0.5), 0 0 100px rgba(255,77,109,0.3);
    letter-spacing: 2px;
    animation: valentinePop 0.6s cubic-bezier(0.17,0.67,0.35,1.5) both;
    animation-delay: 0.3s;
    opacity: 0;
  }
  @keyframes valentinePop {
    0% { transform: scale(0.3); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
  }
  #heartBurst {
    position: absolute;
    inset: 0;
    pointer-events: none;
    overflow: visible;
  }
  .burst-heart {
    position: absolute;
    left: 50%; top: 50%;
    font-size: 1.2rem;
    animation: burstOut ease-out forwards;
    pointer-events: none;
  }
  @keyframes burstOut {
    0% { transform: translate(-50%,-50%) scale(0.3) rotate(0deg); opacity: 1; }
    20% { opacity: 1; transform: translate(calc(-50% + var(--tx) * 0.3), calc(-50% + var(--ty) * 0.3)) scale(1.2) rotate(30deg); }
    100% { transform: translate(calc(-50% + var(--tx)), calc(-50% + var(--ty))) scale(0.4) rotate(180deg); opacity: 0; }
  }
  .hearts-bg {
    position: fixed; inset: 0; pointer-events: none;
    overflow: hidden; z-index: 1;
  }
  .heart-float {
    position: absolute; bottom: -30px;
    color: rgba(255,107,138,0.12);
    animation: floatUp linear infinite;
  }
  @keyframes floatUp {
    0% { transform: translateY(0) rotate(0deg); opacity: 0; }
    5% { opacity: 1; } 95% { opacity: 1; }
    100% { transform: translateY(-110vh) rotate(360deg); opacity: 0; }
  }
  @keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }
</style>
</head>
<body>
<div class="hearts-bg" id="heartsBg"></div>
<div id="landing">
  <div class="heart-icon">&#10084;</div>
  <h1>I Love The Zou</h1>
  <p class="subtitle">Happy Valentine's my Love</p>
  <button class="btn" id="playBtn">Catch Zouzou!</button>
</div>
<canvas id="gameCanvas"></canvas>
<div id="instructions">WASD or Arrow Keys to move ¬∑ Hold Space to sprint</div>
<div id="catchOverlay">
  <canvas id="catchCanvas" width="360" height="300"></canvas>
  <h2>I Love You my Zouzou!</h2>
  <div id="valentineWrap">
    <h1 id="valentineText">Happy Valentine's!</h1>
    <div id="heartBurst"></div>
  </div>
  <p class="timer-text" id="timerText"></p>
  <button class="btn" id="replayBtn">Play Again</button>
</div>

<script>
// ============================================================
// CONSTANTS
// ============================================================
const PLAYER_SPEED = 210;
const SPRINT_MULT = 1.5;
const BOT_BASE_MULT = 1.2;   // Zouzou is 1.2x Loulou's speed by default
const BOT_ROUND_BONUS = 0.1; // +0.1x speed per round
const CATCH_DIST = 42;

// Sprite dimensions (source PNGs)
const SPRITE_W = 124;
const SPRITE_H = 230;
const TOGETHER_W = 175;
const TOGETHER_H = 244;
const CHAR_RENDER_H = 90; // rendered height in game pixels

// Direction enum
const DIR = { FRONT: 0, BACK: 1, RIGHT: 2, LEFT: 3 };

// ============================================================
// STATE
// ============================================================
let canvas, ctx, catchCanvas, catchCtx;
let W, H;
let gameState = 'landing';
let gameTime = 0;
let frameCount = 0;
let keys = {};
let touchDir = { x: 0, y: 0 };
let touchActive = false;
let touchStartX = 0, touchStartY = 0;
let lastTapTime = 0;
let touchSprinting = false;

const player = { x: 0, y: 0, vx: 0, vy: 0, facing: 1, moving: false, sprinting: false, dir: DIR.FRONT, animTimer: 0, animFrame: 0 };
const bot = { x: 0, y: 0, vx: 0, vy: 0, facing: -1, moving: false, changeTimer: 0, pauseTimer: 0, paused: false, dir: DIR.FRONT, animTimer: 0, animFrame: 0 };
let hearts = [];
let bgHearts = [];
let lastTime = 0;
let round = 0;
let botSpeed = PLAYER_SPEED * BOT_BASE_MULT;

// ============================================================
// SPRITE LOADING
// ============================================================
let spritesReady = false;
let spritesLoadedCount = 0;
const TOTAL_SPRITES = 28;

const loulouSprites = []; // 12 images (indices 0-11)
const zouzouSprites = []; // 12 images (indices 0-11)
const togetherSprites = []; // 4 images (indices 0-3)

function onSpriteLoad() {
  spritesLoadedCount++;
  if (spritesLoadedCount >= TOTAL_SPRITES) spritesReady = true;
}

// Load Loulou sprites (files 1-12)
for (let i = 1; i <= 12; i++) {
  const img = new Image();
  img.onload = onSpriteLoad;
  img.src = 'loulou/loulou_zouzou-removebg (' + i + ').png';
  loulouSprites.push(img);
}

// Load Zouzou sprites (files 1-12)
for (let i = 1; i <= 12; i++) {
  const img = new Image();
  img.onload = onSpriteLoad;
  img.src = 'zouzou/loulou_zouzou-removebg (' + i + ').png';
  zouzouSprites.push(img);
}

// Load Together sprites (files 13-16)
for (let i = 13; i <= 16; i++) {
  const img = new Image();
  img.onload = onSpriteLoad;
  img.src = 'loulouzouzou/loulou_zouzou-removebg (' + i + ').png';
  togetherSprites.push(img);
}

// ============================================================
// SPRITE SELECTION & DRAWING
// ============================================================
// Sprite index layout (0-indexed into sprite arrays):
//   Idle: 0=front, 1=back, 2=right, 3=left
//   Walk: 4=front, 5=back, 6=right, 7=left
//   Run:  8=front, 9=back, 10=right, 11=left

function getSpriteIndex(dir, isMoving, isSprinting, animFrame) {
  if (!isMoving) return dir; // idle row: 0-3
  if (!isSprinting) {
    // Toggle between idle and walk frames
    return animFrame === 0 ? dir : (4 + dir);
  }
  // Sprinting: toggle between walk and run frames
  return animFrame === 0 ? (4 + dir) : (8 + dir);
}

function dirFromVelocity(vx, vy, currentDir) {
  const ax = Math.abs(vx);
  const ay = Math.abs(vy);
  if (ax < 5 && ay < 5) return currentDir; // keep last direction when nearly stopped
  if (ax > ay) {
    return vx > 0 ? DIR.RIGHT : DIR.LEFT;
  }
  return vy > 0 ? DIR.FRONT : DIR.BACK;
}

function drawCharacter(c, sprites, x, y, dir, isMoving, isSprinting, animFrame, scale) {
  if (!spritesReady) return;
  const idx = getSpriteIndex(dir, isMoving, isSprinting, animFrame);
  const img = sprites[idx];
  if (!img || !img.complete) return;
  const sh = CHAR_RENDER_H * scale;
  const sw = (SPRITE_W / SPRITE_H) * sh;
  c.imageSmoothingEnabled = true;
  c.imageSmoothingQuality = 'high';
  c.drawImage(img, x - sw / 2, y - sh, sw, sh);
}

function drawTogether(c, x, y, spriteIndex, scale) {
  if (!spritesReady) return;
  const img = togetherSprites[spriteIndex];
  if (!img || !img.complete) return;
  const sh = CHAR_RENDER_H * scale;
  const sw = (TOGETHER_W / TOGETHER_H) * sh;
  c.imageSmoothingEnabled = true;
  c.imageSmoothingQuality = 'high';
  c.drawImage(img, x - sw / 2, y - sh, sw, sh);
}

function drawLoulou(c, bx, by, frame, facing, scl) {
  const sc = scl || 1;
  drawCharacter(c, loulouSprites, bx, by, player.dir, player.moving, player.sprinting && player.moving, player.animFrame, sc);
}

function drawZouzou(c, bx, by, frame, facing, scl) {
  const sc = scl || 1;
  drawCharacter(c, zouzouSprites, bx, by, bot.dir, bot.moving, false, bot.animFrame, sc);
}

// ============================================================
// DRAW HEART SHAPE
// ============================================================
function drawHeart(c, x, y, size, color) {
  c.save();
  c.translate(x, y);
  c.fillStyle = color;
  c.beginPath();
  const s = size;
  c.moveTo(0, s * 0.3);
  c.bezierCurveTo(0, 0, -s, 0, -s, s * 0.35);
  c.bezierCurveTo(-s, s * 0.75, 0, s * 0.95, 0, s * 1.2);
  c.bezierCurveTo(0, s * 0.95, s, s * 0.75, s, s * 0.35);
  c.bezierCurveTo(s, 0, 0, 0, 0, s * 0.3);
  c.fill();
  c.restore();
}

// ============================================================
// HEART PARTICLES
// ============================================================
function spawnHeart(x, y, burst) {
  const angle = Math.random() * Math.PI * 2;
  const speed = burst ? 80 + Math.random() * 160 : 20 + Math.random() * 40;
  const colors = ['#ff4d6d', '#ff6b8a', '#ff8fa3', '#ffb3c6', '#ff1744', '#e91e63'];
  hearts.push({
    x, y,
    vx: Math.cos(angle) * speed,
    vy: Math.sin(angle) * speed - (burst ? 60 : 30),
    size: 4 + Math.random() * 8,
    color: colors[Math.floor(Math.random() * colors.length)],
    life: 1.5 + Math.random() * 1.5,
    maxLife: 2.5,
    rot: Math.random() * Math.PI * 2
  });
}

function updateHearts(dt) {
  for (let i = hearts.length - 1; i >= 0; i--) {
    const h = hearts[i];
    h.x += h.vx * dt;
    h.y += h.vy * dt;
    h.vy += 40 * dt;
    h.life -= dt;
    h.rot += dt * 2;
    if (h.life <= 0) hearts.splice(i, 1);
  }
}

function drawHearts(c) {
  for (const h of hearts) {
    c.save();
    c.globalAlpha = Math.min(1, h.life / 0.5);
    c.translate(h.x, h.y);
    c.rotate(h.rot);
    drawHeart(c, 0, 0, h.size, h.color);
    c.restore();
  }
  c.globalAlpha = 1;
}

// ============================================================
// BACKGROUND
// ============================================================
function initBgHearts() {
  const container = document.getElementById('heartsBg');
  for (let i = 0; i < 15; i++) {
    const h = document.createElement('span');
    h.className = 'heart-float';
    h.textContent = '\u2764';
    h.style.left = Math.random() * 100 + '%';
    h.style.fontSize = (1 + Math.random() * 2) + 'rem';
    h.style.animationDuration = (8 + Math.random() * 12) + 's';
    h.style.animationDelay = (Math.random() * 10) + 's';
    container.appendChild(h);
  }
}

function drawGameBg(c) {
  const grad = c.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#1e0f28');
  grad.addColorStop(0.5, '#2d1b35');
  grad.addColorStop(1, '#1a0a1e');
  c.fillStyle = grad;
  c.fillRect(0, 0, W, H);
  c.fillStyle = 'rgba(255,107,138,0.03)';
  c.fillRect(0, H * 0.85, W, H * 0.15);
  for (const h of bgHearts) {
    c.save();
    c.globalAlpha = h.alpha;
    drawHeart(c, h.x, h.y, h.size, 'rgba(255,107,138,0.15)');
    c.restore();
  }
  c.globalAlpha = 1;
}

function updateBgHearts(dt) {
  if (bgHearts.length < 8 && Math.random() < dt * 0.5) {
    bgHearts.push({
      x: Math.random() * W, y: H + 20,
      size: 5 + Math.random() * 12,
      speed: 15 + Math.random() * 25,
      alpha: 0.05 + Math.random() * 0.1
    });
  }
  for (let i = bgHearts.length - 1; i >= 0; i--) {
    bgHearts[i].y -= bgHearts[i].speed * dt;
    if (bgHearts[i].y < -30) bgHearts.splice(i, 1);
  }
}

// ============================================================
// LABELS AND SHADOWS
// ============================================================
function drawCharShadow(c, x, y) {
  c.save();
  c.globalAlpha = 0.2;
  c.fillStyle = '#000';
  c.beginPath();
  c.ellipse(x, y + 6, 22, 7, 0, 0, Math.PI * 2);
  c.fill();
  c.restore();
}

function drawLabel(c, x, y, name, color) {
  c.font = 'bold 13px Georgia, serif';
  c.textAlign = 'center';
  c.fillStyle = 'rgba(0,0,0,0.5)';
  c.fillText(name, x + 1, y + 1);
  c.fillStyle = color;
  c.fillText(name, x, y);
}

// ============================================================
// INPUT
// ============================================================
function setupInput() {
  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '].includes(e.key.toLowerCase())) e.preventDefault();
  });
  window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
  canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    touchActive = true;
    // Double-tap detection for sprint toggle
    const now = Date.now();
    if (now - lastTapTime < 350) {
      touchSprinting = !touchSprinting;
    }
    lastTapTime = now;
  });
  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (!touchActive) return;
    const dx = e.touches[0].clientX - touchStartX;
    const dy = e.touches[0].clientY - touchStartY;
    const d = Math.sqrt(dx * dx + dy * dy);
    if (d > 10) { touchDir.x = dx / d; touchDir.y = dy / d; }
  });
  canvas.addEventListener('touchend', e => {
    e.preventDefault();
    touchActive = false;
    touchDir.x = 0; touchDir.y = 0;
  });
}

function getInputDir() {
  let dx = 0, dy = 0;
  if (keys['w'] || keys['arrowup']) dy -= 1;
  if (keys['s'] || keys['arrowdown']) dy += 1;
  if (keys['a'] || keys['arrowleft']) dx -= 1;
  if (keys['d'] || keys['arrowright']) dx += 1;
  if (touchActive && (touchDir.x || touchDir.y)) { dx = touchDir.x; dy = touchDir.y; }
  const len = Math.sqrt(dx * dx + dy * dy);
  return len > 0 ? { x: dx / len, y: dy / len } : { x: 0, y: 0 };
}

// ============================================================
// BOT AI
// ============================================================
function updateBot(dt) {
  const dx = bot.x - player.x;
  const dy = bot.y - player.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const margin = 50;

  // Always flee away from Loulou
  if (dist > 0) {
    // Base flee direction: directly away from player
    let fleeX = dx / dist;
    let fleeY = dy / dist;

    // Add some randomness so she doesn't just run in a straight line
    // Less randomness when close (panic mode), more when far
    const jitter = dist < 150 ? 0.15 : 0.5;
    fleeX += (Math.random() - 0.5) * jitter;
    fleeY += (Math.random() - 0.5) * jitter;

    // Steer away from walls to avoid getting cornered
    if (bot.x < margin + 80) fleeX += 0.5;
    if (bot.x > W - margin - 80) fleeX -= 0.5;
    if (bot.y < margin + 80) fleeY += 0.5;
    if (bot.y > H - margin - 80) fleeY -= 0.5;

    // Normalize
    const fLen = Math.sqrt(fleeX * fleeX + fleeY * fleeY);
    if (fLen > 0) { fleeX /= fLen; fleeY /= fLen; }

    // Accelerate harder when player is close
    const urgency = dist < 120 ? 8 : 5;
    bot.vx += fleeX * botSpeed * urgency * dt;
    bot.vy += fleeY * botSpeed * urgency * dt;
  }
  bot.moving = true;

  // Clamp to max speed
  const spd = Math.sqrt(bot.vx * bot.vx + bot.vy * bot.vy);
  if (spd > botSpeed) { bot.vx = (bot.vx / spd) * botSpeed; bot.vy = (bot.vy / spd) * botSpeed; }
  bot.vx *= Math.pow(0.02, dt);
  bot.vy *= Math.pow(0.02, dt);
  bot.x += bot.vx * dt;
  bot.y += bot.vy * dt;

  // Bounce off walls
  if (bot.x < margin) { bot.x = margin; bot.vx = Math.abs(bot.vx); }
  if (bot.x > W - margin) { bot.x = W - margin; bot.vx = -Math.abs(bot.vx); }
  if (bot.y < margin + 40) { bot.y = margin + 40; bot.vy = Math.abs(bot.vy); }
  if (bot.y > H - margin) { bot.y = H - margin; bot.vy = -Math.abs(bot.vy); }
  if (Math.abs(bot.vx) > 5) bot.facing = bot.vx > 0 ? 1 : -1;

  // Direction detection for sprites
  bot.dir = dirFromVelocity(bot.vx, bot.vy, bot.dir);

  // Animation frame toggling (bot is always "running")
  bot.animTimer += dt;
  const botAnimRate = 0.15;
  if (bot.animTimer >= botAnimRate) {
    bot.animTimer -= botAnimRate;
    bot.animFrame = bot.animFrame === 0 ? 1 : 0;
  }
}

// ============================================================
// PLAYER
// ============================================================
function updatePlayer(dt) {
  const dir = getInputDir();
  player.sprinting = keys[' '] || keys['shift'] || touchSprinting;
  const speed = PLAYER_SPEED * (player.sprinting ? SPRINT_MULT : 1);
  player.vx = dir.x * speed;
  player.vy = dir.y * speed;
  player.moving = dir.x !== 0 || dir.y !== 0;
  player.x += player.vx * dt;
  player.y += player.vy * dt;
  const margin = 40;
  player.x = Math.max(margin, Math.min(W - margin, player.x));
  player.y = Math.max(margin + 40, Math.min(H - margin, player.y));
  if (Math.abs(player.vx) > 5) player.facing = player.vx > 0 ? 1 : -1;

  // Direction detection for sprites
  player.dir = dirFromVelocity(player.vx, player.vy, player.dir);

  // Animation frame toggling
  if (player.moving) {
    const rate = (player.sprinting) ? 0.15 : 0.25;
    player.animTimer += dt;
    if (player.animTimer >= rate) {
      player.animTimer -= rate;
      player.animFrame = player.animFrame === 0 ? 1 : 0;
    }
  } else {
    player.animTimer = 0;
    player.animFrame = 0;
  }
}

// ============================================================
// COLLISION
// ============================================================
function checkCatch() {
  const dx = player.x - bot.x;
  const dy = player.y - bot.y;
  return Math.sqrt(dx * dx + dy * dy) < CATCH_DIST;
}

// ============================================================
// CATCH
// ============================================================
function triggerCatch() {
  gameState = 'caught';
  for (let i = 0; i < 50; i++) {
    spawnHeart((player.x + bot.x) / 2, (player.y + bot.y) / 2 - 40, true);
  }
  setTimeout(() => {
    const overlay = document.getElementById('catchOverlay');
    overlay.style.display = 'flex';
    document.getElementById('timerText').textContent = 'Caught in ' + gameTime.toFixed(1) + ' seconds!';
    drawCatchScene();
    // Reset valentine text animation
    const vt = document.getElementById('valentineText');
    vt.style.animation = 'none';
    vt.offsetHeight; // force reflow
    vt.style.animation = '';
    // Spawn heart burst from the valentine text
    spawnHeartBurst();
    requestAnimationFrame(() => overlay.classList.add('visible'));
  }, 1200);
}

function spawnHeartBurst() {
  const container = document.getElementById('heartBurst');
  container.innerHTML = '';
  const emojis = ['\u2764\uFE0F', '\uD83D\uDC96', '\uD83D\uDC97', '\uD83D\uDC95', '\uD83D\uDC9E', '\uD83D\uDC93', '\u2763\uFE0F'];
  const colors = ['#ff4d6d','#ff6b8a','#ff8fa3','#ffb3c6','#ff1744','#e91e63','#ff69b4'];
  for (let i = 0; i < 40; i++) {
    const h = document.createElement('span');
    h.className = 'burst-heart';
    h.textContent = emojis[Math.floor(Math.random() * emojis.length)];
    const angle = (Math.PI * 2 * i / 40) + (Math.random() - 0.5) * 0.5;
    const dist = 80 + Math.random() * 200;
    const tx = Math.cos(angle) * dist;
    const ty = Math.sin(angle) * dist - 40;
    const dur = 1.2 + Math.random() * 1.5;
    const delay = Math.random() * 0.6;
    const size = 0.8 + Math.random() * 1.8;
    h.style.fontSize = size + 'rem';
    h.style.animationDuration = dur + 's';
    h.style.animationDelay = delay + 's';
    h.style.setProperty('--tx', tx + 'px');
    h.style.setProperty('--ty', ty + 'px');
    container.appendChild(h);
  }
  // Second wave
  setTimeout(() => {
    for (let i = 0; i < 25; i++) {
      const h = document.createElement('span');
      h.className = 'burst-heart';
      h.textContent = emojis[Math.floor(Math.random() * emojis.length)];
      const angle = Math.random() * Math.PI * 2;
      const dist = 60 + Math.random() * 250;
      const tx = Math.cos(angle) * dist;
      const ty = Math.sin(angle) * dist - 30;
      const dur = 1 + Math.random() * 1.8;
      const size = 0.6 + Math.random() * 1.5;
      h.style.fontSize = size + 'rem';
      h.style.animationDuration = dur + 's';
      h.style.animationDelay = '0s';
      h.style.setProperty('--tx', tx + 'px');
      h.style.setProperty('--ty', ty + 'px');
      container.appendChild(h);
    }
  }, 800);
}

function drawCatchScene() {
  const cc = catchCtx;
  const cw = catchCanvas.width;
  const ch = catchCanvas.height;
  cc.clearRect(0, 0, cw, ch);
  const cx = cw / 2;
  const cy = ch * 0.85;

  // Draw together sprite (index 1 = tight hug, M-left) scaled up for the overlay
  drawTogether(cc, cx, cy, 1, 2.0);

  // Floating hearts around the hugging couple
  drawHeart(cc, cx, cy - 150, 18, '#ff4d6d');
  drawHeart(cc, cx - 60, cy - 120, 8, '#ff8fa3');
  drawHeart(cc, cx + 60, cy - 115, 9, '#ffb3c6');
  drawHeart(cc, cx - 45, cy - 145, 6, '#ff6b8a');
  drawHeart(cc, cx + 50, cy - 143, 5, '#ff4d6d');
  drawHeart(cc, cx, cy - 170, 6, '#ffb3c6');
}

// ============================================================
// GAME INIT
// ============================================================
function initGame() {
  canvas = document.getElementById('gameCanvas');
  ctx = canvas.getContext('2d');
  catchCanvas = document.getElementById('catchCanvas');
  catchCtx = catchCanvas.getContext('2d');

  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  setupInput();
  initBgHearts();

  document.getElementById('playBtn').addEventListener('click', startGame);
  document.getElementById('replayBtn').addEventListener('click', () => {
    document.getElementById('catchOverlay').classList.remove('visible');
    setTimeout(() => {
      document.getElementById('catchOverlay').style.display = 'none';
      document.getElementById('heartBurst').innerHTML = '';
      startGame();
    }, 600);
  });

  if ('ontouchstart' in window) {
    document.getElementById('instructions').textContent = 'Touch and drag to move ¬∑ Double tap to toggle sprint';
  }
  requestAnimationFrame(gameLoop);
}

function resizeCanvas() {
  W = window.innerWidth;
  H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;
}

function startGame() {
  gameState = 'playing';
  gameTime = 0; frameCount = 0;
  hearts = []; bgHearts = [];
  touchSprinting = false;

  // Increase bot speed each round
  botSpeed = PLAYER_SPEED * (BOT_BASE_MULT + round * BOT_ROUND_BONUS);
  round++;

  player.x = W * 0.25; player.y = H * 0.55;
  player.vx = 0; player.vy = 0;
  player.facing = 1; player.moving = false;
  player.dir = DIR.FRONT; player.animTimer = 0; player.animFrame = 0;

  bot.x = W * 0.75; bot.y = H * 0.55;
  bot.vx = 0; bot.vy = 0;
  bot.facing = -1; bot.moving = false;
  bot.changeTimer = 1; bot.paused = false; bot.pauseTimer = 0;
  bot.dir = DIR.FRONT; bot.animTimer = 0; bot.animFrame = 0;

  document.getElementById('landing').classList.add('hidden');
  canvas.style.display = 'block';
  document.getElementById('instructions').style.display = 'block';
  document.getElementById('instructions').style.opacity = '1';
  setTimeout(() => {
    document.getElementById('instructions').style.opacity = '0';
  }, 4000);
}

// ============================================================
// GAME LOOP
// ============================================================
function gameLoop(timestamp) {
  const dt = Math.min(0.05, (timestamp - lastTime) / 1000);
  lastTime = timestamp;

  if (gameState === 'playing') {
    gameTime += dt;
    frameCount++;
    updatePlayer(dt);
    updateBot(dt);
    updateBgHearts(dt);
    updateHearts(dt);

    if (bot.moving && frameCount % 25 === 0) {
      spawnHeart(bot.x, bot.y, false);
    }

    if (checkCatch()) triggerCatch();

    drawGameBg(ctx);

    ctx.font = '14px Georgia, serif';
    ctx.textAlign = 'right';
    ctx.fillStyle = 'rgba(255,179,198,0.4)';
    ctx.fillText(gameTime.toFixed(1) + 's', W - 15, 25);

    drawCharShadow(ctx, bot.x, bot.y);
    drawZouzou(ctx, bot.x, bot.y, frameCount, bot.facing);
    drawLabel(ctx, bot.x, bot.y + 18, 'Zouzou', '#ffb3c6');

    drawCharShadow(ctx, player.x, player.y);
    drawLoulou(ctx, player.x, player.y, frameCount, player.facing);
    drawLabel(ctx, player.x, player.y + 18, 'Loulou', '#ff8fa3');

    drawHearts(ctx);
  } else if (gameState === 'caught') {
    updateHearts(dt);
    drawGameBg(ctx);
    // Draw together sprite at midpoint of player and bot
    const midX = (player.x + bot.x) / 2;
    const midY = (player.y + bot.y) / 2;
    drawCharShadow(ctx, midX, midY);
    drawTogether(ctx, midX, midY, 1, 1);
    drawHearts(ctx);
  }

  requestAnimationFrame(gameLoop);
}

window.addEventListener('DOMContentLoaded', initGame);
</script>
</body>
</html>
